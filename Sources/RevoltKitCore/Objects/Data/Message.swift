//
//  Message.swift
//  
//
//  Created by gulje on 20.06.2023.
//

import Foundation

public struct Message: Codable, Equatable {
    public static func == (lhs: Message, rhs: Message) -> Bool {
        lhs.content == rhs.content
    }
    
    private enum CodingKeys: String, CodingKey {
        case id = "_id"
        case nonce
        case channel
        case author
        case webhook
        case content
        case system
        case attachments
        case edited
        case embeds
        case mentions
        case replies
        case reactions
        case interactions
        case masquerade
    }
    
    /// Unique ID
    public let id: String
    
    /// Unique value generated by client sending this message
    public let nonce: String?
    
    /// ID of the channel this message was sent in
    public let channel: String
    
    /// ID of the user or webhook that sent this message
    public let author: String
    
    /// Information about the webhook bundled with Message
    public let webhook: Webhook?
    
    /// Message content
    public let content: String?
    
    /// System message
    public let system: SystemMessageData?
    
    /// Attachments
    public let attachments: [File]?
    
    /// ISO8601 formatted timestamp
    public let edited: String?
    
    /// Attached embeds to this message
    public let embeds: [Embed]?
    
    /// Array of user IDs mentioned in this message
    public let mentions: [String]?
    
    /// Array of message IDs this message is replying to
    public let replies: [String]?
    
    /// Hashmap of emoji IDs to array of user IDs
    public let reactions: [String: [String]]?
    
    /// Information about how this message should be interacted with
    public let interactions: Interactions?
    
    /// Name and / or avatar overrides for this message
    public let masquerade: Masquerade?
}

// MASQUERADE

public struct Masquerade: Codable {
    public let name: String?
    
    public let avatar: String?
    
    /// Must have `ManageRole` permission to use
    public let colour: String?
}

// INTERACTIONS

public struct Interactions: Codable {
    /// Reactions which should always appear and be distinct
    public let reactions: [String]?
    
    /// Whether reactions should be restricted to the given list.
    /// Can only be set to true if reactions list is of at least length 1
    public let restrict_reactions: Bool?
}

// WEBHOOK

public struct Webhook: Codable {
    public let name: String
    public let avatar: String?
}

// SYSTEM MESSAGE

public struct SystemMessageData: Codable {
    public let type: SystemMessageType
    
    /// Present in `text`
    public let content: String?
    
    /// Present in `user_added`, `user_remove`, `user_joined`, `user_left`,
    /// `user_kicked`, `user_banned`
    public let id: String?
    
    /// Present in `user_added`, `user_remove`, `channel_renamed`, `channel_description_changed`,
    /// `channel_icon_changed`
    public let by: String?
    
    /// Present in `channel_renamed`
    public let name: String?
    
    /// Present in `channel_ownership_changed`
    public let from: String?
    
    /// Present in `channel_ownership_changed`
    public let to: String?
}

public enum SystemMessageType: String, Codable {
    case text
    case user_added
    case user_remove
    case user_joined
    case user_left
    case user_kicked
    case user_banned
    case channel_renamed
    case channel_description_changed
    case channel_icon_changed
    case channel_ownership_changed
}

// EMBED

public struct Embed: Codable {
    public let type: EmbedType
    
    /// Direct URL to web page, video or image ,present in `Website`,  `Image`, `Text` and`Video`
    public let url: String?
    
    /// Original direct URL, present in `Website`
    public let original_url: String?
    
    /// Present in `Website`
    public let special: SpecialRemoteContent?
    
    /// Present in `Website` and `Text`
    public let title: String?
    
    /// Present in `Website` and `Text`
    public let description: String?
    
    /// Present in `Website`
    public let image: EmbeddedImage?
    
    /// Present in `Website`
    public let video: EmbeddedVideo?
    
    /// Present in `Website`
    public let site_name: String?
    
    /// Present in `Website` and `Text`
    public let icon_url: String?
    
    /// Present in `Website` and `Text`
    public let colour: String?
    
    /// Present in `Image`, `Video`
    public let width: Int?
    
    /// Present in `Image`, `Video`
    public let height: Int?
    
    /// Present in `Image`
    public let size: ImageSizeType?
    
    /// Present in `Text`
    public let media: File?
}

public enum EmbedType: String, Codable {
    case Website
    case Image
    case Video
    case Text
    case None
}

public struct EmbeddedVideo: Codable {
    public let url: String
    public let width: Int
    public let height: Int
}

public struct EmbeddedImage: Codable {
    public let url: String
    public let width: Int
    public let height: Int
    public let size: ImageSizeType
}

public enum ImageSizeType: String, Codable {
    case Large
    case Preview
}

public struct SpecialRemoteContent: Codable {
    public let type: SpecialRemoteContentType
    
    /// Not present in `None`, `GIF` and `Soundcloud`
    public let id: String?
    
    /// Present in `YouTube`
    public let timestamp: String?
    
    /// Present in `Lightspeed`, `Bandcamp`, `Spotify` and `Twitch`
    public let content_type: SpecialRemoteContentTypes?
}

public enum SpecialRemoteContentTypes: Codable {
    case string(String)
    case enumValue(SpecialRemoteContentTypeEnum)
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        
        if let stringValue = try? container.decode(String.self) {
            self = .string(stringValue)
        } else if let enumValue = try? container.decode(SpecialRemoteContentTypeEnum.self) {
            self = .enumValue(enumValue)
        } else {
            throw DecodingError.typeMismatch(
                SpecialRemoteContentTypeEnum.self,
                DecodingError.Context(
                    codingPath: decoder.codingPath,
                    debugDescription: "Invalid type"
                )
            )
        }
    }
}

public enum SpecialRemoteContentTypeEnum: String, Codable {
    /// `Twitch`
    case Video
    case Clip
    
    /// `Bandcamp`
    case Album
    case Track
    
    /// `Lightspeed` and `Twitch`
    case Channel
}

public enum SpecialRemoteContentType: String, Codable {
    case None
    case GIF
    case YouTube
    case Lightspeed
    case Twitch
    case Spotify
    case Soundcloud
    case Bandcamp
    case Streamable
}
